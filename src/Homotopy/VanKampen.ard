\import Data.Or
\import Equiv
\import Equiv.Sigma
\import Homotopy.Pushout
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\class Sequences \noclassifying {A : \Type} {L R : \Type} (toL : A -> L) (toR : A -> R) {
  -- Example:
  -- (p0 : l = f(x1)),
  -- (x1 : A), (q1 : g(x1) = g(y1)),
  -- (y1 : A), (p1 : f(y1) = f(x2)),
  -- (x2 : A), (q2 : g(x2) = g(y2)),
  -- (y2 : A), (p2 : f(y2) = l')

  \data Points
    | nil
    | \infixl 5 :: Points A

  \data SegmentsLL (l : L) (xs : Points) (l' : L) : \oo-Type \elim xs
    | nil => ll (l = l')
    | :: xs y => \infixl 5 :l: (SegmentsLR l xs (toR y)) (toL y = l')

  \data SegmentsLR (l : L) (xs : Points) (r : R) : \oo-Type \elim xs
    | :: xs x => \infixl 5 :r: (SegmentsLL l xs (toL x)) (toR x = r)

  \func SeqLL (l l' : L) => Given {xs} (SegmentsLL l xs l')

  \func SeqLR (l : L) (r : R) => Given {xs} (SegmentsLR l xs r)

  \data \infix 6 ~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') : \oo-Type \elim seq, seq' {
    | ((:: (:: nil a) a'), :l: (:r: (ll p1) q1) p2), (nil, ll p12') =>
    ll-reduce-q-idp1
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12')
    | ((:: (:: (:: xs y) a) a'), :l: (:r: (:l: seq p1) q1) p2), (:: xs' y', :l: seq' p12') =>
    ll-reduce-q-idp2
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12' with y=y')
    | (:: xs y, :l: seq p), (:: xs' y', :l: seq' p') =>
    ll-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~lr~> (xs', seq' with y=y'))
      (p = p' with y=y')
  }

  \data \infix 6 ~lr~> {l : L} {r : R} (seq : SeqLR l r) (seq' : SeqLR l r) : \oo-Type \elim seq, seq' {
    | ((:: (:: (:: xs y) a) a'), :r: (:l: (:r: seq q1) p1) q2), (:: xs' y', :r: seq' q12') =>
    lr-reduce-p-idp
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (p1 with a=a' = idp)
      (q1 with a=a' *> q2 = q12' with y=y')
    | (:: xs y, :r: seq q), (:: xs' y', :r: seq' q') =>
    lr-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~ll~> (xs', seq' with y=y'))
      (q = q' with y=y')
  }

  \meta \infixl 10 with x p => rewriteF p x <|> rewriteF (inv p) x

  \func \infix 6 <~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') => seq ~ll~> seq' `Or` seq' ~ll~> seq

  \func \infix 6 <~lr~> {r : R} {l : L} (seq : SeqLR l r) (seq' : SeqLR l r) => seq ~lr~> seq' `Or` seq' ~lr~> seq

  \func SeqLL/~ (l l' : L) => Quotient {SeqLL l l'} (<~ll~>)

  \func SeqLR/~ (l : L) (r : R) => Quotient {SeqLR l r} (<~lr~>)

  \func seq-ll-equiv-seq-lr (l : L) (a : A) : QEquiv {SeqLL/~ l (toL a)} {SeqLR/~ l (toR a)} \cowith
    | f (seq/~ : SeqLL/~ l (toL a)) : SeqLR/~ l (toR a) \with {
      | in~ seq => in~ (seq `:r:idp)
      | ~-equiv seq1 seq2 equiv i => ~-equiv (seq1 `:r:idp) (seq2 `:r:idp) (equiv-lemma1 equiv) i
    }
    | ret (seq/~ : SeqLR/~ l (toR a)) : SeqLL/~ l (toL a) \with {
      | in~ seq => in~ (seq `:l:idp)
      | ~-equiv seq1 seq2 equiv i => ~-equiv (seq1 `:l:idp) (seq2 `:l:idp) (equiv-lemma2 equiv) i
    }
    | ret_f => \case \elim __ \with {
      | in~ seq => path (~-equiv (seq `:r:idp `:l:idp) seq (equiv-lemma3 seq))
    }
    | f_sec => \case \elim __ \with {
      | in~ seq => path (~-equiv (seq `:l:idp `:r:idp) seq (equiv-lemma4 seq))
    }
    \where {
      \func :r:idp {l : L} {a : A} (seq : SeqLL l (toL a)) : SeqLR l (toR a) \elim seq
        | (xs, seg) => (xs :: a, seg :r: idp)

      \func :l:idp {l : L} {a : A} (seq : SeqLR l (toR a)) : SeqLL l (toL a) \elim seq
        | (xs, seg) => (xs :: a, seg :l: idp)

      \func equiv-lemma1 {l : L} {a : A} {seq : SeqLL l (toL a)} {seq' : SeqLL l (toL a)} (equiv : seq <~ll~> seq')
        : seq `:r:idp <~lr~> seq' `:r:idp =>
        Or.map (lr-reduce-cons idp __ idp) (lr-reduce-cons idp __ idp) equiv

      \func equiv-lemma2 {l : L} {a : A} {seq : SeqLR l (toR a)} {seq' : SeqLR l (toR a)} (equiv : seq <~lr~> seq')
        : seq `:l:idp <~ll~> seq' `:l:idp =>
        Or.map (ll-reduce-cons idp __ idp) (ll-reduce-cons idp __ idp) equiv

      \func equiv-lemma3 {l : L} {a : A} (seq : SeqLL l (toL a)) : seq `:r:idp `:l:idp <~ll~> seq
        | (nil, ll p) => inl (ll-reduce-q-idp1 idp idp idp)
        | (:: xs y, :l: seg p) => inl (ll-reduce-q-idp2 idp idp idp idp idp idp)

      \func equiv-lemma4 {l : L} {a : A} (seq : SeqLR l (toR a)) : seq `:l:idp `:r:idp <~lr~> seq
        | (nil, ())
        | (:: xs y, :r: seg p) => inl (lr-reduce-p-idp idp idp idp idp idp idp)
    }
}

\class VanKampen \noclassifying (A B C : \Type) (f : A -> B) (g : A -> C) {
  \instance SequencesBC : Sequences f g

  \instance SequencesCB : Sequences g f

  \func code (p1 p2 : PushoutData f g) : \Set
    | pinl b, pinl b' => SequencesBC.SeqLL/~ b b'
    | pinr c, pinr c' => SequencesCB.SeqLL/~ c c'
    | pinl b, pinr c => SequencesBC.SeqLR/~ b c
    | pinr c, pinl b => SequencesCB.SeqLR/~ c b
    | pinl b, pglue a i => equiv= (SequencesBC.seq-ll-equiv-seq-lr b a) @ i
    | pinr c, pglue a i => inv (equiv= (SequencesCB.seq-ll-equiv-seq-lr c a)) @ i
    | pglue a i, pinl b => {?} -- TODO try to prove that Seq is equiv to it's inverse and use that fact
    | pglue a i, pinr c => {?}
    | pglue a i, pglue a' i' => {?} -- TODO be brave
}