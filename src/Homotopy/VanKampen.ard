\import Data.List
\import Data.Or
\import Homotopy.Pushout
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\class Sequences \noclassifying (A : \Type) {L R : \Type} (toL : A -> L) (toR : A -> R) {
  \data Points
    | two A A
    | cons A A Points

  \func first (xs : Points) : A
    | two x y => x
    | cons x y xs => x

  \func last (xs : Points) : A
    | two x y => y
    | cons x y xs => last xs

  -- Example: (x1 : A), (q1 : g(x1) = g(y1)), (y1 : A), (p1 : f(y1) = f(x2)), (x2 : A), (q2 : g(x2) = g(y2)), (y2 : A)

  \data Segments (xs : Points) \elim xs
    | two x y => one-seg (toR x = toR y)
    | cons x y xs => cons-seg (toR x = toR y) (toL y = toL (first xs)) (Segments xs)

  \data SeqLL (l l' : L)
    | single-ll (l = l')
    | segments-ll (xs : Points) (l = toL (first xs)) (Segments xs) (toL (last xs) = l')

  \data SeqLR (l : L) (r : R)
    | segments-lr (xs : Points) (l = toL (first xs)) (Segments xs) (toR (last xs) = r)

  \data \infixl 6 ~> {xs : Points} (s : Segments xs) {xs' : Points} (s' : Segments xs') \elim xs, s, xs', s' {
    | cons x a (two a' y), cons-seg q1 p1 (one-seg q2), two x' y', (one-seg q2') =>
    p-idp1
      (x=x' : x = x')
      (a=a' : a = a') (p1 with a=a' = idp)
      (y=y' : y = y') (q1 with a=a' *> q2 = q2' with x=x' with y=y')

    | cons x a (cons a' y xs), cons-seg q1 p1 (cons-seg q2 p2 s), cons x' y' xs', cons-seg q2' p2' s' =>
    p-idp2
      (x=x' : x = x')
      (a=a' : a = a') (p1 with a=a' = idp)
      (y=y' : y = y') (q1 with a=a' *> q2 = q2' with x=x' with y=y')
      (xs=xs' : xs = xs') (p2 = p2' with y=y' with xs=xs')
      (s = s' with xs=xs')

    | cons x y (cons a a' xs), cons-seg q1 p1 (cons-seg q2 p2 s), cons x' y' xs', cons-seg q1' p1' s' =>
    q-idp
      (x=x' : x = x')
      (y=y' : y = y') (q1 with x=x' with y=y' = q1')
      (a=a' : a = a') (q2 with a=a' = idp)
      (xs=xs' : xs = xs') (p1 with a=a' *> p2 = p1' with y=y' with pmap first xs=xs')
      (s = s' with xs=xs')

    | cons x y xs, cons-seg q p s, cons x' y' xs', cons-seg q' p' s' =>
    cons-reduce
      (x=x' : x = x')
      (y=y' : y = y') (q = q' with x=x' with y=y')
      (first-xs=first-xs' : first xs = first xs') (p = p' with y=y' with first-xs=first-xs')
      (s ~> s')
  }

  \data \infix 6 ~ll~> {l l' : L} (seq seq' : SeqLL l l') \with {
    | segments-ll xs p0 s pn, segments-ll xs' p0' s' pn' =>
    seq-ll-reduce
      (first-xs=-first-xs' : first xs = first xs') (p0 = p0' with first-xs=-first-xs')
      (last-xs=last-xs' : last xs = last xs') (pn = pn' with last-xs=last-xs')
      (s ~> s')
  }

  \data \infix 6 ~lr~> {l : L} {r : R} (seq seq' : SeqLR l r) \with {
    | segments-lr xs p0 s pn, segments-lr xs' p0' s' pn' =>
    seq-lr-reduce
      (first-xs=-first-xs' : first xs = first xs') (p0 = p0' with first-xs=-first-xs')
      (last-xs=last-xs' : last xs = last xs') (pn = pn' with last-xs=last-xs')
      (s ~> s')
  }

  \meta \infixl 10 with x p => rewriteF p x <|> rewriteF (inv p) x

  \func \infix 6 <~ll~> {l l' : L} (seq seq' : SeqLL l l') =>
    seq ~ll~> seq' `Or` seq' ~ll~> seq

  \func \infix 6 <~lr~> {l : L} {r : R} (seq seq' : SeqLR l r) =>
    seq ~lr~> seq' `Or` seq' ~lr~> seq
}

\class VanKampen \noclassifying (A B C : \Type) (f : A -> B) (g : A -> C) {
  \instance SeqBC : Sequences A f g
  \instance SeqCB : Sequences A g f

  \func code (p1 p2 : PushoutData f g) : \Set
    | pinl b, pinl b' => Quotient {SeqBC.SeqLL b b'} (SeqBC.<~ll~>)
    | pinr c, pinr c' => Quotient {SeqCB.SeqLL c c'} (SeqCB.<~ll~>)
    | pinl b, pinr c => Quotient {SeqBC.SeqLR b c} (SeqBC.<~lr~>)
    | pinr c, pinl b => Quotient {SeqCB.SeqLR c b} (SeqCB.<~lr~>)
    | pinl b, pglue a i => {?}
    | pinr c, pglue a i => {?}
    | pglue a i, pinl b => {?}
    | pglue a i, pinr c => {?}
    | pglue a i, pglue a' i' => {?}
}