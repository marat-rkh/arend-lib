\import Data.Or
\import Homotopy.Pushout
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\class VanKampen \noclassifying (A B C : \Type) (f : A -> B) (g : A -> C) {
  \data Points
    | two A A
    | cons A A Points

  \func first (xs : Points) : A
    | two x y => x
    | cons x y xs => x

  \func last (xs : Points) : A
    | two x y => y
    | cons x y xs => last xs

  -- Example: (x1 : A), (q1 : g(x1) = g(y1)), (y1 : A), (p1 : f(y1) = f(x2)), (x2 : A), (q2 : g(x2) = g(y2)), (y2 : A)

  \data Segments {L R : \Type} (xs : Points) (toL : A -> L) (toR : A -> R) \elim xs
    | two x y => one-seg (toR x = toR y)
    | cons x y xs => cons-seg (toR x = toR y) (toL y = toL (first xs)) (Segments xs toL toR)

  \data Seq {L R : \Type} (toL : A -> L) (toR : A -> R)
    | single (l l' : L) (l = l')
    | segments (l : L) (xs : Points) (l' : L) (l = toL (first xs)) (Segments xs toL toR) (toL (last xs) = l')

  \data \infixl 6 ~> {L R : \Type} {toL : A -> L} {toR : A -> R}
                     {xs : Points} (s : Segments xs toL toR)
                     {xs' : Points} (s' : Segments xs' toL toR)
  \elim xs, s, xs', s' {
    | cons x a (two a' y), cons-seg q1 p1 (one-seg q2), two x' y', (one-seg q2') =>
    p-idp1
      (x=x' : x = x')
      (a=a' : a = a') (p1 with a=a' = idp)
      (y=y' : y = y') (q1 with a=a' *> q2 = q2' with x=x' with y=y')

    | cons x a (cons a' y xs), cons-seg q1 p1 (cons-seg q2 p2 s), cons x' y' xs', cons-seg q2' p2' s' =>
    p-idp2
      (x=x' : x = x')
      (a=a' : a = a') (p1 with a=a' = idp)
      (y=y' : y = y') (q1 with a=a' *> q2 = q2' with x=x' with y=y')
      (xs=xs' : xs = xs') (p2 = p2' with y=y' with xs=xs')
      (s = s' with xs=xs')

    | cons x y (cons a a' xs), cons-seg q1 p1 (cons-seg q2 p2 s), cons x' y' xs', cons-seg q1' p1' s' =>
    q-idp
      (x=x' : x = x')
      (y=y' : y = y') (q1 with x=x' with y=y' = q1')
      (a=a' : a = a') (q2 with a=a' = idp)
      (xs=xs' : xs = xs') (p1 with a=a' *> p2 = p1' with y=y' with pmap first xs=xs')
      (s = s' with xs=xs')

    | cons x y xs, cons-seg q p s, cons x' y' xs', cons-seg q' p' s' =>
    cons-reduce
      (x=x' : x = x')
      (y=y' : y = y') (q = q' with x=x' with y=y')
      (first-xs=first-xs' : first xs = first xs') (p = p' with y=y' with first-xs=first-xs')
      (s ~> s')
  }

  \data \infix 6 ~~> {L R : \Type} {toL : A -> L} {toR : A -> R} (seq seq' : Seq toL toR) \with {
    | segments l1 xs l2 p0 s pn, segments l1' xs' l2' p0' s' pn' =>
    seq-reduce
      (l1=l1' : l1 = l1')
      (l2=l2' : l2 = l2')
      (first-xs=-first-xs' : first xs = first xs') (p0 = p0' with l1=l1' with first-xs=-first-xs')
      (last-xs=last-xs' : last xs = last xs') (pn = pn' with l2=l2' with last-xs=last-xs')
      (s ~> s')
  }

  \meta \infixl 10 with x p => rewriteF p x <|> rewriteF (inv p) x

  \func \infix 6 <~~> {L R : \Type} {toL : A -> L} {toR : A -> R} (seq seq' : Seq toL toR) =>
    seq ~~> seq' `Or` seq' ~~> seq

  \func code (p1 p2 : PushoutData f g) : \Set
    | pinl b, pinl b' => Quotient {Seq f g} (<~~>)
    | pinr c, pinr c' => {?}
    | pinl b, pinr c => {?}
    | pinr c, pinl b => {?}
    | pglue a i, pinl b => {?}
    | pglue a i, pinr c => {?}
    | pinl b, pglue a i => {?}
    | pinr c, pglue a i => {?}
    | pglue a i, pglue a1 i1 => {?}
}