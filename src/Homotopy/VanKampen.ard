\import Data.Or
\import Equiv
\import Equiv.Sigma
\import Homotopy.Pushout
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\class Sequence \noclassifying {A : \Type} {L R : \Type} (toL : A -> L) (toR : A -> R) {
  -- Example:
  -- (p0 : l = f(x1)),
  -- (x1 : A), (q1 : g(x1) = g(y1)),
  -- (y1 : A), (p1 : f(y1) = f(x2)),
  -- (x2 : A), (q2 : g(x2) = g(y2)),
  -- (y2 : A), (p2 : f(y2) = l')

  \data Points
    | nil
    | \infixl 5 :: Points A

  \func \infixl 5 ++ (xs ys : Points) : Points \elim ys
    | nil => xs
    | :: ys y => xs ++ ys :: y

  \data SegmentsLL (l : L) (xs : Points) (l' : L) : \Type \elim xs
    | nil => ll (l = l')
    | :: xs y => \infixl 5 :l: (SegmentsLR l xs (toR y)) (toL y = l')

  \data SegmentsLR (l : L) (xs : Points) (r : R) : \Type \elim xs
    | :: xs x => \infixl 5 :r: (SegmentsLL l xs (toL x)) (toR x = r)

  \func SeqLL (l l' : L) => Given {xs} (SegmentsLL l xs l')

  \func SeqLR (l : L) (r : R) => Given {xs} (SegmentsLR l xs r)

  -- TODO why do we need this \oo-Type?

  \data \infix 6 ~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') : \oo-Type \elim seq, seq' {
    | ((:: (:: nil a) a'), :l: (:r: (ll p1) q1) p2), (nil, ll p12') =>
    ll-reduce-q-idp1
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12')
    | ((:: (:: (:: xs y) a) a'), :l: (:r: (:l: seq p1) q1) p2), (:: xs' y', :l: seq' p12') =>
    ll-reduce-q-idp2
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12' with y=y')
    | (:: xs y, :l: seq p), (:: xs' y', :l: seq' p') =>
    ll-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~lr~> (xs', seq' with y=y'))
      (p = p' with y=y')
  }

  \data \infix 6 ~lr~> {l : L} {r : R} (seq : SeqLR l r) (seq' : SeqLR l r) : \oo-Type \elim seq, seq' {
    | ((:: (:: (:: xs y) a) a'), :r: (:l: (:r: seq q1) p1) q2), (:: xs' y', :r: seq' q12') =>
    lr-reduce-p-idp
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (p1 with a=a' = idp)
      (q1 with a=a' *> q2 = q12' with y=y')
    | (:: xs y, :r: seq q), (:: xs' y', :r: seq' q') =>
    lr-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~ll~> (xs', seq' with y=y'))
      (q = q' with y=y')
  }

  \meta \infixl 10 with x p => rewriteF p x <|> rewriteF (inv p) x

  \func \infix 6 <~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') => seq ~ll~> seq' `Or` seq' ~ll~> seq

  \func \infix 6 <~lr~> {r : R} {l : L} (seq : SeqLR l r) (seq' : SeqLR l r) => seq ~lr~> seq' `Or` seq' ~lr~> seq

  \func SeqLL/~ (l l' : L) => Quotient {SeqLL l l'} (<~ll~>)

  \func SeqLR/~ (l : L) (r : R) => Quotient {SeqLR l r} (<~lr~>)

  \func seq-ll-equiv-seq-lr (l : L) (a : A) : QEquiv {SeqLL/~ l (toL a)} {SeqLR/~ l (toR a)} \cowith
    | f (seq/~ : SeqLL/~ l (toL a)) : SeqLR/~ l (toR a) \with {
      | in~ seq => in~ (seq `:r:idp)
      | ~-equiv seq1 seq2 equiv i => ~-equiv (seq1 `:r:idp) (seq2 `:r:idp) (equiv-lemma1 equiv) i
    }
    | ret (seq/~ : SeqLR/~ l (toR a)) : SeqLL/~ l (toL a) \with {
      | in~ seq => in~ (seq `:l:idp)
      | ~-equiv seq1 seq2 equiv i => ~-equiv (seq1 `:l:idp) (seq2 `:l:idp) (equiv-lemma2 equiv) i
    }
    | ret_f => \case \elim __ \with {
      | in~ seq => path (~-equiv (seq `:r:idp `:l:idp) seq (equiv-lemma3 seq))
    }
    | f_sec => \case \elim __ \with {
      | in~ seq => path (~-equiv (seq `:l:idp `:r:idp) seq (equiv-lemma4 seq))
    }
    \where {
      \func :r:idp {l : L} {a : A} (seq : SeqLL l (toL a)) : SeqLR l (toR a) \elim seq
        | (xs, seg) => (xs :: a, seg :r: idp)

      \func :l:idp {l : L} {a : A} (seq : SeqLR l (toR a)) : SeqLL l (toL a) \elim seq
        | (xs, seg) => (xs :: a, seg :l: idp)

      \func equiv-lemma1 {l : L} {a : A} {seq : SeqLL l (toL a)} {seq' : SeqLL l (toL a)} (equiv : seq <~ll~> seq')
        : seq `:r:idp <~lr~> seq' `:r:idp =>
        Or.map (lr-reduce-cons idp __ idp) (lr-reduce-cons idp __ idp) equiv

      \func equiv-lemma2 {l : L} {a : A} {seq : SeqLR l (toR a)} {seq' : SeqLR l (toR a)} (equiv : seq <~lr~> seq')
        : seq `:l:idp <~ll~> seq' `:l:idp =>
        Or.map (ll-reduce-cons idp __ idp) (ll-reduce-cons idp __ idp) equiv

      \func equiv-lemma3 {l : L} {a : A} (seq : SeqLL l (toL a)) : seq `:r:idp `:l:idp <~ll~> seq
        | (nil, ll p) => inl (ll-reduce-q-idp1 idp idp idp)
        | (:: xs y, :l: seg p) => inl (ll-reduce-q-idp2 idp idp idp idp idp idp)

      \func equiv-lemma4 {l : L} {a : A} (seq : SeqLR l (toR a)) : seq `:l:idp `:r:idp <~lr~> seq
        | (nil, ())
        | (:: xs y, :r: seg p) => inl (lr-reduce-p-idp idp idp idp idp idp idp)
    }
}

\class Sequences \noclassifying {A : \Type} {L R : \Type} {toL : A -> L} {toR : A -> R}
                                (Seq : Sequence toL toR) (InvSeq : Sequence toR toL) {
  \func SeqLL => Seq.SeqLL

  \func SeqLL/~ => Seq.SeqLL/~

  \func SeqLR => Seq.SeqLR

  \func SeqLR/~ => Seq.SeqLR/~

  \func SeqRR => InvSeq.SeqLL

  \func SeqRR/~ => InvSeq.SeqLL/~

  \func SeqRL => InvSeq.SeqLR

  \func SeqRL/~ => InvSeq.SeqLR/~

  \func inv-seq-ll (l l' : L) : SeqLL/~ l l' = SeqLL/~ l' l => equiv= (equiv l l')
    \where {
      \open Sequence (nil, ::, ++, <~ll~>, <~lr~>)
      -- TODO false positive
      \open Sequence.SegmentsLL (ll, :l:)
      \open Sequence.SegmentsLR (:r:)
      \open Sequence.~ll~> (ll-reduce-cons)
      \open Sequence.~lr~> (lr-reduce-cons)

      \func equiv (l l' : L) : QEquiv {SeqLL/~ l l'} {SeqLL/~ l' l} => \new QEquiv {
        | f => \case \elim __ \with {
          | in~ seq => {?}
          | ~-equiv x y r i => {?}
        }
        | ret => {?}
        | ret_f => {?}
        | f_sec => {?}
      }

      \func reverse {l l' : L} (seq : SeqLL l l') : SeqLL l' l
        | (nil, ll p) => (nil, ll (inv p))
        | (:: nil y, :l: () p)
        | (:: (:: xs x) y, :l: (:r: seg q) p) =>
          -- TODO hard... try to define equivalence on SeqLL level instead of SeqLL/~
          \let (rev-xs, rev-seg) => reverse (xs, seg) \in (nil :: y :: x ++ rev-xs, {?})
    }

  \func inv-seq-rl (l : L) (r : R) : SeqRL/~ r l = SeqLR/~ l r => equiv= (\new QEquiv {_} {_} {
    | f => {?}
    | ret => {?}
    | ret_f => {?}
    | f_sec => {?}
  })

  \func seq-ll-equiv-seq-lr2 (a : A) (l : L) : QEquiv {SeqLL/~ (toL a) l} {SeqRL/~ (toR a) l} =>
    rewrite (inv-seq-ll (toL a) l) (rewrite (inv-seq-rl l (toR a)) (Seq.seq-ll-equiv-seq-lr l a))

  --  \func seq-ll-equiv-seq-lr2 (a : A) (l : L) : QEquiv {SeqLL/~ (toL a) l} {SeqRL/~ (toR a) l} \cowith
  --    | f => \case \elim __ \with {
  --      | in~ seq => in~ (idp:r: seq)
  --      | ~-equiv seq1 seq2 equiv i => ~-equiv (idp:r: seq1) (idp:r: seq2) (equiv-lemma1 equiv) i
  --    }
  --    | ret => \case \elim __ \with {
  --      | in~ seq => in~ (idp:l: seq)
  --      | ~-equiv seq1 seq2 equiv i => ~-equiv (idp:l: seq1) (idp:l: seq2) {?} i
  --    }
  --    | ret_f => {?}
  --    | f_sec => {?}
  --    \where {
  --      \open Sequence (nil, ::, <~ll~>, <~lr~>)
  --      -- TODO false positive
  --
--      \open Sequence.SegmentsLL (ll, :l:)
  --      \open Sequence.SegmentsLR (:r:)
  --      \open Sequence.~ll~> (ll-reduce-cons)
  --      \open Sequence.~lr~> (lr-reduce-cons)
  --
--      \func idp:r: {l : L} {a : A} (seq : SeqLL (toL a) l) : SeqRL (toR a) l \elim seq
  --        | (nil, ll p) => (nil :: a, ll idp :r: p)
  --        | (:: nil y, :l: () p)
  --        | (:: (:: xs x) y, :l: (:r: seg q) p) =>
  --          \let (a::xs, idp:r:seg) => idp:r: (xs, seg)
  --          \in (a::xs :: x :: y, idp:r:seg :l: q :r: p)
  --
--      \func idp:l: {l : L} {a : A} (seq : SeqRL (toR a) l) : SeqLL (toL a) l \elim seq
  --        | (nil, ())
  --        | (:: nil x, :r: (ll p) q) => (nil :: a :: x, ll idp :r: p :l: q)
  --        | (:: (:: xs y) x, :r: (:l: seg p) q) =>
  --          \let (a::xs, idp:l:seg) => idp:l: (xs, seg)
  --          \in (a::xs :: y :: x, idp:l:seg :r: p :l: q)
  --
--      \func equiv-lemma1 {l : L} {a : A} {seq1 : SeqLL (toL a) l} {seq2 : SeqLL (toL a) l} (equiv : seq1 Seq.<~ll~> seq2)
  --        : idp:r: seq1 InvSeq.<~lr~> idp:r: seq2 =>
  --        {?} -- TODO we do not have a rule for such redunctions...
  --    }
}

\class VanKampen \noclassifying (A B C : \Type) (f : A -> B) (g : A -> C) {
  \instance SequenceBC : Sequence f g

  \instance SequenceCB : Sequence g f

  \instance SequencesBC : Sequences SequenceBC SequenceCB

  \instance SequencesCB : Sequences SequenceCB SequenceBC

  \func code (p1 p2 : PushoutData f g) : \Set
    | pinl b, pinl b' => SequenceBC.SeqLL/~ b b'
    | pinr c, pinr c' => SequenceCB.SeqLL/~ c c'
    | pinl b, pinr c => SequenceBC.SeqLR/~ b c
    | pinr c, pinl b => SequenceCB.SeqLR/~ c b
    -- TODO if I extract the left argument of @ to a function, typechecking fails for some reason.
    | pinl b, pglue a i => equiv= (SequenceBC.seq-ll-equiv-seq-lr b a) @ i
    | pinr c, pglue a i => inv (equiv= (SequenceCB.seq-ll-equiv-seq-lr c a)) @ i
    | pglue a i, pinl b => equiv= (SequencesBC.seq-ll-equiv-seq-lr2 a b) @ i
    | pglue a i, pinr c => inv (equiv= (SequencesCB.seq-ll-equiv-seq-lr2 a c)) @ i
    | pglue a i, pglue a' i' => {?} -- TODO be brave
}