\import Data.Or
\import Homotopy.Pushout
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\class Sequences \noclassifying (A : \Type) {L R : \Type} (toL : A -> L) (toR : A -> R) {
  -- Example:
  -- (p0 : l = f(x1)),
  -- (x1 : A), (q1 : g(x1) = g(y1)),
  -- (y1 : A), (p1 : f(y1) = f(x2)),
  -- (x2 : A), (q2 : g(x2) = g(y2)),
  -- (y2 : A), (p2 : f(y2) = l')

  \data Points
    | nil
    | \infixl 5 :: Points A

  \data SegmentsLL (l : L) (xs : Points) (l' : L) : \oo-Type \elim xs
    | nil => ll (l = l')
    | :: xs y => \infixl 5 :l: (SegmentsLR l xs (toR y)) (toL y = l')

  \data SegmentsLR (l : L) (xs : Points) (r : R) : \oo-Type \elim xs
    | :: xs x => :r: (SegmentsLL l xs (toL x)) (toR x = r)

  \func SeqLL (l l' : L) => Given {xs} (SegmentsLL l xs l')

  \func SeqLR (l : L) (r : R) => Given {xs} (SegmentsLR l xs r)

  \data \infix 6 ~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') : \oo-Type
  \elim seq, seq' {
    | (:: (:: (:: (:: xs x) a) a') y, :l: (:r: (:l: (:r: seq q1) p1) q2) p2), (:: (:: xs' x') y', :l: (:r: seq' q12') p2') =>
    ll-reduce-p-idp
      (xs=xs' : xs = xs')
      (x=x' : x = x')
      (seq = seq' with xs=xs' with x=x')
      (a=a' : a = a')
      (p1 with a=a' = idp)
      (y=y' : y = y')
      (q1 with a=a' *> q2 = q12' with x=x' with y=y')
      (p2 = p2' with y=y')
    | ((:: (:: (:: xs y) a) a'), :l: (:r: (:l: seq p1) q1) p2), (:: xs' y', :l: seq' p12') =>
    ll-reduce-q-idp
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12' with y=y')
    | (:: xs y, :l: seq p), (:: xs' y', :l: seq' p') =>
    ll-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~lr~> (xs', seq' with y=y'))
      (p = p' with y=y')
  }

  \data \infix 6 ~lr~> {l : L} {r : R} (seq : SeqLR l r) (seq' : SeqLR l r) : \oo-Type
  \elim seq, seq' {
    | (:: (:: (:: (:: xs x) a) a') y, :r: (:l: (:r: (:l: seq p1) q1) p2) q2), (:: (:: xs' x') y', :r: (:l: seq' p12') q2') =>
    lr-reduce-q-idp
      (xs=xs' : xs = xs')
      (x=x' : x = x')
      (seq = seq' with xs=xs' with x=x')
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (y=y' : y = y')
      (p1 with a=a' *> p2 = p12' with x=x' with y=y')
      (q2 = q2' with y=y')
    | ((:: (:: (:: xs y) a) a'), :r: (:l: (:r: seq q1) p1) q2), (:: xs' y', :r: seq' q12') =>
    lr-reduce-p-idp
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (p1 with a=a' = idp)
      (q1 with a=a' *> q2 = q12' with y=y')
    | (:: xs y, :r: seq q), (:: xs' y', :r: seq' q') =>
    lr-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~ll~> (xs', seq' with y=y'))
      (q = q' with y=y')
  }

  \meta \infixl 10 with x p => rewriteF p x <|> rewriteF (inv p) x

  \func \infix 6 <~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') =>
    seq ~ll~> seq' `Or` seq' ~ll~> seq

  \func \infix 6 <~lr~> {r : R} {l : L} (seq : SeqLR l r) (seq' : SeqLR l r) =>
    seq ~lr~> seq' `Or` seq' ~lr~> seq

  --  \func append-toR {l : L} {a : A} (seq : SeqLL l (toL a)) : SeqLR l (toR a)
  --    | ll p => lr {?} {?} {?} {?}
  --    | lrl xs p s p1 => {?}
}

\class VanKampen \noclassifying (A B C : \Type) (f : A -> B) (g : A -> C) {
  \instance SequencesBC : Sequences A f g

  \instance SequencesCB : Sequences A g f

  \func code (p1 p2 : PushoutData f g) : \Set
    | pinl b, pinl b' => Quotient {SequencesBC.SeqLL b b'} (SequencesBC.<~ll~>)
    | pinr c, pinr c' => Quotient {SequencesCB.SeqLL c c'} (SequencesCB.<~ll~>)
    | pinl b, pinr c => Quotient {SequencesBC.SeqLR b c} (SequencesBC.<~lr~>)
    | pinr c, pinl b => Quotient {SequencesCB.SeqLR c b} (SequencesCB.<~lr~>)
    | pinl b, pglue a i => {?}
    | pinr c, pglue a i => {?}
    | pglue a i, pinl b => {?}
    | pglue a i, pinr c => {?}
    | pglue a i, pglue a' i' => {?}
}