\import Data.Or
\import Equiv
\import Equiv.Sigma
\import Homotopy.Pushout
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence

\class Sequence \noclassifying {A : \Type} {L R : \Type} (toL : A -> L) (toR : A -> R) {
  -- Example:
  -- (p0 : l = f(x1)),
  -- (x1 : A), (q1 : g(x1) = g(y1)),
  -- (y1 : A), (p1 : f(y1) = f(x2)),
  -- (x2 : A), (q2 : g(x2) = g(y2)),
  -- (y2 : A), (p2 : f(y2) = l')

  \data Points
    | nil
    | \infixl 5 :: Points A

  \func reverse-pts (xs : Points) : Points
    | nil => nil
    | :: xs a => nil :: a ++ reverse-pts xs

  \func \infixl 5 ++ (xs ys : Points) : Points \elim ys
    | nil => xs
    | :: ys y => xs ++ ys :: y

  \func ++-assoc {xs ys zs : Points} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs) \elim zs
    | nil => idp
    | :: zs z => pmap (`:: z) ++-assoc


  \data SegmentsLL (l : L) (xs : Points) (l' : L) : \Type \elim xs
    | nil => ll (l = l')
    | :: xs y => \infixl 5 :l: (SegmentsLR l xs (toR y)) (toL y = l')

  \data SegmentsLR (l : L) (xs : Points) (r : R) : \Type \elim xs
    | :: xs x => \infixl 5 :r: (SegmentsLL l xs (toL x)) (toR x = r)

  \func reverse-seg-ll {l l' : L} {xs : Points} (seg : SegmentsLL l xs l') : SegmentsLL l' (reverse-pts xs) l
  \elim xs, seg
    | nil, ll p => ll (inv p)
    | :: xs y, :l: seg p => helper-lr seg (ll (inv p))
    \where {
      \func helper-lr {l : L} {xs : Points} {a : A}
                      (seg : SegmentsLR l xs (toR a))
                      {l' : L} {ys : Points}
                      (acc : SegmentsLL l' ys (toL a)) : SegmentsLL l' (ys :: a ++ reverse-pts xs) l \elim xs, seg
        | :: xs a', :r: seg q =>
          \let rec => helper-ll seg (:r: acc (inv q))
            -- TODO replacing `inv ++-assoc` with `++-assoc` leads to IOOB exception
          \in rewrite (inv ++-assoc) rec

      \func helper-ll {l : L} {xs : Points} {a : A}
                      (seg : SegmentsLL l xs (toL a))
                      {l' : L} {ys : Points}
                      (acc : SegmentsLR l' ys (toR a)) : SegmentsLL l' (ys :: a ++ reverse-pts xs) l \elim xs, seg
        | nil, ll p => acc :l: inv p
        | :: xs a', :l: seg p =>
          \let rec => helper-lr seg (:l: acc (inv p))
          \in rewrite (inv ++-assoc) rec
    }


  \func SeqLL (l l' : L) => Given {xs} (SegmentsLL l xs l')

  \func SeqLR (l : L) (r : R) => Given {xs} (SegmentsLR l xs r)

  \func reverse-seq-ll {l l' : L} (seq : SeqLL l l') : SeqLL l' l \elim seq
    | (xs, seg) => (reverse-pts xs, reverse-seg-ll seg)


  -- TODO why do we need this \oo-Type?

  \data \infix 6 ~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') : \oo-Type \elim seq, seq' {
    | ((:: (:: nil a) a'), :l: (:r: (ll p1) q1) p2), (nil, ll p12') =>
    ll-reduce-q-idp1
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12')
    | ((:: (:: (:: xs y) a) a'), :l: (:r: (:l: seq p1) q1) p2), (:: xs' y', :l: seq' p12') =>
    ll-reduce-q-idp2
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (q1 with a=a' = idp)
      (p1 with a=a' *> p2 = p12' with y=y')
    | (:: xs y, :l: seq p), (:: xs' y', :l: seq' p') =>
    ll-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~lr~> (xs', seq' with y=y'))
      (p = p' with y=y')
  }

  \data \infix 6 ~lr~> {l : L} {r : R} (seq : SeqLR l r) (seq' : SeqLR l r) : \oo-Type \elim seq, seq' {
    | ((:: (:: (:: xs y) a) a'), :r: (:l: (:r: seq q1) p1) q2), (:: xs' y', :r: seq' q12') =>
    lr-reduce-p-idp
      (xs=xs' : xs = xs')
      (y=y' : y = y')
      (seq = seq' with xs=xs' with y=y')
      (a=a' : a = a')
      (p1 with a=a' = idp)
      (q1 with a=a' *> q2 = q12' with y=y')
    | (:: xs y, :r: seq q), (:: xs' y', :r: seq' q') =>
    lr-reduce-cons
      (y=y' : y = y')
      ((xs, seq) ~ll~> (xs', seq' with y=y'))
      (q = q' with y=y')
  }

  \meta \infixl 10 with x p => rewriteF p x <|> rewriteF (inv p) x

  \func \infix 6 <~ll~> {l l' : L} (seq : SeqLL l l') (seq' : SeqLL l l') => seq ~ll~> seq' `Or` seq' ~ll~> seq

  \func \infix 6 <~lr~> {r : R} {l : L} (seq : SeqLR l r) (seq' : SeqLR l r) => seq ~lr~> seq' `Or` seq' ~lr~> seq

  \func SeqLL/~ (l l' : L) => Quotient {SeqLL l l'} (<~ll~>)

  \func SeqLR/~ (l : L) (r : R) => Quotient {SeqLR l r} (<~lr~>)

  \func seq-ll-equiv-seq-lr (l : L) (a : A) : QEquiv {SeqLL/~ l (toL a)} {SeqLR/~ l (toR a)} \cowith
    | f (seq/~ : SeqLL/~ l (toL a)) : SeqLR/~ l (toR a) \with {
      | in~ seq => in~ (seq `:r:idp)
      | ~-equiv seq1 seq2 equiv i => ~-equiv (seq1 `:r:idp) (seq2 `:r:idp) (equiv-lemma1 equiv) i
    }
    | ret (seq/~ : SeqLR/~ l (toR a)) : SeqLL/~ l (toL a) \with {
      | in~ seq => in~ (seq `:l:idp)
      | ~-equiv seq1 seq2 equiv i => ~-equiv (seq1 `:l:idp) (seq2 `:l:idp) (equiv-lemma2 equiv) i
    }
    | ret_f => \case \elim __ \with {
      | in~ seq => path (~-equiv (seq `:r:idp `:l:idp) seq (equiv-lemma3 seq))
    }
    | f_sec => \case \elim __ \with {
      | in~ seq => path (~-equiv (seq `:l:idp `:r:idp) seq (equiv-lemma4 seq))
    }
    \where {
      \func :r:idp {l : L} {a : A} (seq : SeqLL l (toL a)) : SeqLR l (toR a) \elim seq
        | (xs, seg) => (xs :: a, seg :r: idp)

      \func :l:idp {l : L} {a : A} (seq : SeqLR l (toR a)) : SeqLL l (toL a) \elim seq
        | (xs, seg) => (xs :: a, seg :l: idp)

      \func equiv-lemma1 {l : L} {a : A} {seq : SeqLL l (toL a)} {seq' : SeqLL l (toL a)} (equiv : seq <~ll~> seq')
        : seq `:r:idp <~lr~> seq' `:r:idp =>
        Or.map (lr-reduce-cons idp __ idp) (lr-reduce-cons idp __ idp) equiv

      \func equiv-lemma2 {l : L} {a : A} {seq : SeqLR l (toR a)} {seq' : SeqLR l (toR a)} (equiv : seq <~lr~> seq')
        : seq `:l:idp <~ll~> seq' `:l:idp =>
        Or.map (ll-reduce-cons idp __ idp) (ll-reduce-cons idp __ idp) equiv

      \func equiv-lemma3 {l : L} {a : A} (seq : SeqLL l (toL a)) : seq `:r:idp `:l:idp <~ll~> seq
        | (nil, ll p) => inl (ll-reduce-q-idp1 idp idp idp)
        | (:: xs y, :l: seg p) => inl (ll-reduce-q-idp2 idp idp idp idp idp idp)

      \func equiv-lemma4 {l : L} {a : A} (seq : SeqLR l (toR a)) : seq `:l:idp `:r:idp <~lr~> seq
        | (nil, ())
        | (:: xs y, :r: seg p) => inl (lr-reduce-p-idp idp idp idp idp idp idp)
    }
}

\class Sequences \noclassifying {A : \Type} {L R : \Type} {toL : A -> L} {toR : A -> R}
                                (Seq : Sequence toL toR) (InvSeq : Sequence toR toL) {
  \func SeqLL => Seq.SeqLL

  \func SeqLL/~ => Seq.SeqLL/~

  \func SeqLR => Seq.SeqLR

  \func SeqLR/~ => Seq.SeqLR/~

  \func SeqRR => InvSeq.SeqLL

  \func SeqRR/~ => InvSeq.SeqLL/~

  \func SeqRL => InvSeq.SeqLR

  \func SeqRL/~ => InvSeq.SeqLR/~

  \func inv-seq-ll (l l' : L) : SeqLL/~ l l' = SeqLL/~ l' l => equiv= (equiv l l')
    \where {
      \open Sequence (nil, ::, ++, <~ll~>, <~lr~>)
      -- TODO false positive
      \open Sequence.SegmentsLL (ll, :l:)
      \open Sequence.SegmentsLR (:r:)
      \open Sequence.~ll~> (ll-reduce-cons)
      \open Sequence.~lr~> (lr-reduce-cons)

      \func equiv (l l' : L) : QEquiv {SeqLL/~ l l'} {SeqLL/~ l' l} \cowith {
        | f => \case \elim __ \with {
          | in~ seq => in~ (Seq.reverse-seq-ll seq)
          | ~-equiv seq1 seq2 r i => ~-equiv (Seq.reverse-seq-ll seq1) (Seq.reverse-seq-ll seq2) (equiv-lemma1 r) i
        }
        | ret => {?}
        | ret_f => {?}
        | f_sec => {?}
      }

      \func equiv-lemma1 {l l' : L} {seq1 seq2 : SeqLL l l'} (r : seq1 Seq.<~ll~> seq2)
        : (Seq.reverse-seq-ll seq1) Seq.<~ll~> (Seq.reverse-seq-ll seq2) => {?}
    }

  \func inv-seq-rl (l : L) (r : R) : SeqRL/~ r l = SeqLR/~ l r => equiv= (\new QEquiv {_} {_} {
    | f => {?}
    | ret => {?}
    | ret_f => {?}
    | f_sec => {?}
  })

  \func seq-ll-equiv-seq-rl (a : A) (l : L) : QEquiv {SeqLL/~ (toL a) l} {SeqRL/~ (toR a) l} =>
    rewrite (inv-seq-ll (toL a) l) (rewrite (inv-seq-rl l (toR a)) (Seq.seq-ll-equiv-seq-lr l a))
}

\class VanKampen \noclassifying (A B C : \Type) (f : A -> B) (g : A -> C) {
  \instance SequenceBC : Sequence f g

  \instance SequenceCB : Sequence g f

  \instance SequencesBC : Sequences SequenceBC SequenceCB

  \instance SequencesCB : Sequences SequenceCB SequenceBC

  \func code (p1 p2 : PushoutData f g) : \Set
    | pinl b, pinl b' => SequenceBC.SeqLL/~ b b'
    | pinr c, pinr c' => SequenceCB.SeqLL/~ c c'
    | pinl b, pinr c => SequenceBC.SeqLR/~ b c
    | pinr c, pinl b => SequenceCB.SeqLR/~ c b
    | pinl b, pglue a => equiv= (SequenceBC.seq-ll-equiv-seq-lr b a)
    | pinr c, pglue a => inv (equiv= (SequenceCB.seq-ll-equiv-seq-lr c a))
    | pglue a, pinl b => equiv= (SequencesBC.seq-ll-equiv-seq-rl a b)
    | pglue a, pinr c => inv (equiv= (SequencesCB.seq-ll-equiv-seq-rl a c))
    | pglue a i, pglue a' i' => {?} -- TODO be brave
}